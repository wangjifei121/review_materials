
### redis数据结构及常用场景
  redis主要的数据结构包括 string、list、hash、set、 zset五种
  - string类型
    - 缓存功能：String字符串是最常用的数据类型，不仅仅是Redis，各个语言都是最基本类型，因此，利用Redis作为缓存，配合其它数据库作为存储层。
    - 计数器：许多系统都会使用Redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。
    - 共享用户Session
  - list类型
    - 消息队列：Redis的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计
    - 列表数据或者数据分页展示的应用
  - hash类型
    - 分组数据的存储
    - 各种复杂的字典结构数据缓存
  - set类型
    - 可借助集合操作的业务数据（去重、集合运算）
  - zset类型
    - 各种排行榜相关业务

 ### redis数据持久化
  Redis 提供了 RDB 和 AOF 两种持久化方式。RDB做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。
  
 ### redis缓存穿透
  产生这个问题的原因可能是外部的恶意攻击，例如，对用户信息进行了缓存，但恶意攻击者使用不存在的用户id频繁请求接口，导致查询缓存不命中，然后穿透 DB 查询依然不命中。这时会有大量请求穿透缓存访问到 DB。
  解决的办法如下：
   - 对不存在的用户，在缓存中保存一个空对象进行标记，防止相同 ID 再次访问 DB。不过有时这个方法并不能很好解决问题，可能导致缓存中存储大量无用数据。
   - 使用 BloomFilter 过滤器，BloomFilter 的特点是存在性检测，如果 BloomFilter 中不存在，那么数据一定不存在；如果 BloomFilter 中存在，实际数据也有可能会不存在。非常适合解决这类的问题。

### BloomFilter 过滤器
- 和HyperLogLog超对数对比
  超对数包含pfadd、pfcount两个命令，但是无法判断一个已知元素在不在HyperLogLog中
- 什么是BloomFilter过滤器
  BloomFilter过滤器是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。
  BloomFilter过滤器时redis4.0版本以后增加的功能，默认不支持，需要添加插件才能适用
- BloomFilter过滤器适用场景
  - 大数据量
  - 不要求准确率100%
  - 需要查询元素是否已经存在
  - 应用场景举例：
    - 根据用户浏览记录给用户推荐内容
    - 爬虫url去重
    - 邮件垃圾箱
    - 挡IO，不存在时再查库
- BloomFilter过滤器常用命令
  ```
  bf.add key val
  bf.existes key val
  bf.madd key val1 val2
  bf.mexistes key val1 val2 val3
  ```
- BloomFilter的准确率
  - BloomFilter过滤器对已经见过的数据肯定不会误判，准确度100%
  - BloomFilter过滤器对未知的数据的准确度默认为99%，可以根据实际需求修改，准确度要求越高，占用空间越大
- 自定义设置BloomFilter的准确率
  - 命令 `bf.reserve`
  - 参数1 `key`
  - 参数2 `error_rate` 默认0.01
  - 参数3 `initial_size` 预计存在元素个数，如果实际数量超过预设数量，准确度会下降，默认值为100
- BloomFilter布隆过滤器图示
![image](https://user-images.githubusercontent.com/40445471/154433140-97311257-e9fe-46a8-ae74-a0d82fc7ba95.png)

  
